pragma solidity ^0.4.23;
/*
 *             ╔═╗┌─┐┌─┐┬┌─┐┬┌─┐┬   ┌─────────────────────────┐ ╦ ╦┌─┐┌┐ ╔═╗┬┌┬┐┌─┐
 *             ║ ║├┤ ├┤ ││  │├─┤│   │ KOL Community Foundation│ │ ║║║├┤ ├┴┐╚═╗│ │ ├┤
 *             ╚═╝└  └  ┴└─┘┴┴ ┴┴─┘ └─┬─────────────────────┬─┘ ╚╩╝└─┘└─┘╚═╝┴ ┴ └─┘
 *   ┌────────────────────────────────┘                     └──────────────────────────────┐
 *   │    ┌─────────────────────────────────────────────────────────────────────────────┐  │
 *   └────┤ Dev:Jack Koe ├─────────────┤ Special for: KOL  ├───────────────┤ 20200422   ├──┘
 *        └─────────────────────────────────────────────────────────────────────────────┘
 */

 library SafeMath {
   function mul(uint a, uint b) internal pure  returns (uint) {
     uint c = a * b;
     require(a == 0 || c / a == b);
     return c;
   }
   function div(uint a, uint b) internal pure returns (uint) {
     require(b > 0);
     uint c = a / b;
     require(a == b * c + a % b);
     return c;
   }
   function sub(uint a, uint b) internal pure returns (uint) {
     require(b <= a);
     return a - b;
   }
   function add(uint a, uint b) internal pure returns (uint) {
     uint c = a + b;
     require(c >= a);
     return c;
   }
   function max64(uint64 a, uint64 b) internal  pure returns (uint64) {
     return a >= b ? a : b;
   }
   function min64(uint64 a, uint64 b) internal  pure returns (uint64) {
     return a < b ? a : b;
   }
   function max256(uint256 a, uint256 b) internal  pure returns (uint256) {
     return a >= b ? a : b;
   }
   function min256(uint256 a, uint256 b) internal  pure returns (uint256) {
     return a < b ? a : b;
   }
 }

 /**
  * title KOL Promotion contract
  * dev visit: https://github.com/jackoelv/KOL/
 */

 contract ERC20Basic {
   uint public totalSupply;
   function balanceOf(address who) public constant returns (uint);
   function transfer(address to, uint value) public;
   event Transfer(address indexed from, address indexed to, uint value);
 }

 contract ERC20 is ERC20Basic {
   function allowance(address owner, address spender) public constant returns (uint);
   function transferFrom(address from, address to, uint value) public;
   function approve(address spender, uint value) public;
   event Approval(address indexed owner, address indexed spender, uint value);
 }

 /**
  * title KOL Promotion contract
  * dev visit: https://github.com/jackoelv/KOL/
 */

 contract BasicToken is ERC20Basic {

   using SafeMath for uint;

   mapping(address => uint) balances;

   function transfer(address _to, uint _value) public{
     balances[msg.sender] = balances[msg.sender].sub(_value);
     balances[_to] = balances[_to].add(_value);
     emit Transfer(msg.sender, _to, _value);
   }

   function balanceOf(address _owner) public constant returns (uint balance) {
     return balances[_owner];
   }
 }

 /**
  * title KOL Promotion contract
  * dev visit: https://github.com/jackoelv/KOL/
 */

 contract StandardToken is BasicToken, ERC20 {
   mapping (address => mapping (address => uint)) allowed;
   uint256 public userSupplyed;

   function transferFrom(address _from, address _to, uint _value) public {
     balances[_to] = balances[_to].add(_value);
     balances[_from] = balances[_from].sub(_value);
     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
     emit Transfer(_from, _to, _value);
   }

   function approve(address _spender, uint _value) public{
     require((_value == 0) || (allowed[msg.sender][_spender] == 0)) ;
     allowed[msg.sender][_spender] = _value;
     emit Approval(msg.sender, _spender, _value);
   }

   function allowance(address _owner, address _spender) public constant returns (uint remaining) {
     return allowed[_owner][_spender];
   }
 }
 contract KOL is StandardToken {
   function queryNode(address _addr) public view returns(bool);
   function querySuperNode(address _addr) public view returns(bool);
 }

 contract KOLP is StrandardToken{
   address public reciever;

   uint256 public begin;//2020年4月22日0点0分0秒
   uint256 public end;

   uint256 public iCode;
   uint256 public every = 10 seconds;//1 days;
   uint256 public maxSettleDays = 1;
   uint256 public totalRegister;
   uint256 public totalBalance;
   uint256 public totalBonus;



   uint8 public constant userLevel1 = 20;
   uint8 public constant userLevel2 = 10;

   /* uint16 public constant comLevel1Users = 100;
   uint16 public constant comLevel2Users = 300;
   uint16 public constant comLevel3Users = 500; */

   //测试的时候就把数字变小一点。
   uint16 public constant comLevel1Users = 2;
   uint16 public constant comLevel2Users = 3;
   uint16 public constant comLevel3Users = 4;

   uint256 public constant comLevel1Amount = 10000 * (10 ** 18);
   uint256 public constant comLevel2Amount = 30000 * (10 ** 18);
   uint256 public constant comLevel3Amount = 50000 * (10 ** 18);

   uint8 public constant comLevel1 = 3;
   uint8 public constant comLevel2 = 5;
   uint8 public constant comLevel3 = 10;
   uint8 public constant withDrawRate = 5;
   uint8 public constant fee = 5;

   /* uint256 public constant withDrawDays = 30 days; */
   //测试限制5分钟
   uint256 public constant withDrawDays = 2 minutes;

   /* address[] private inviteAddr;// A->B->C: inviteAddr= B,A
   address[] private childAddr;// A-->B,A-->C,childAddr= B, C */



   struct lock{
     uint256 begin;
     uint256 amount;
     uint256 end;
     bool withDrawed;
   }

   struct teamRate{
     uint8 rate;
     uint256 changeTime;

   }

   struct inviteBonus{
     uint256 begin;//网体开始时间
     uint256 dayBonus;//网体当日加速
     uint256 hisTotalBonus;
   }
   struct withDraws{
     uint256 time;
     uint256 amount;
   }
   struct dayTeamBonus{
     uint256 theDayLastSecond;
     uint256 theDayTeamBonus;
     uint256 totalTeamBonus;
     uint8 theDayRate;
   }
   struct dayInviteBonus{
     uint256 theDayLastSecond;
     uint256 theDayInviteBonus;
     uint256 totalInviteBonus;
   }



   mapping (address => dayTeamBonus[]) internal LockTeamBonus;
   mapping (address => dayInviteBonus[]) internal LockInviteBonus;


   mapping (address => address[]) internal InviteList;
   mapping (address => address[]) internal ChildAddrs;
   mapping (address => teamRate[]) internal TeamRateList;
   mapping (address => lock[]) internal LockHistory;
   mapping (address => uint256) internal LockBalance;

   mapping (address => uint256) internal InviteHistoryBonus;
   mapping (address => uint256) internal InviteCurrentDayBonus;

   mapping (address => address) internal InviteRelation;//A=>B B is father;
   mapping (uint256 => uint256) public ClosePrice;//需要给个默认值，而且还允许修改，否则忘记就很麻烦了。
   mapping (address => uint256) internal TotalUsers;
   mapping (address => uint256) internal TotalLockingAmount;
   mapping (uint256 => address) public InviteCode;
   mapping (address => uint256) public RInviteCode;

   mapping (address => uint8) internal isLevelN;
   mapping (uint8 => uint8) internal levelRate;
   mapping (address => bool) public USDTOrCoin;

   mapping (address => uint256) internal WithDraws;
   mapping (address => mapping (address => uint256) ) ABTeamBonus;//A是下级，B是上级，ABBonus就是A给B加速的总数。
   mapping (address => mapping (address => uint256) ) ABInviteBonus;//A是下级，B是上级，ABBonus就是A给B加速的总数。

 }
 /**
  * title KOL Promotion contract
  * dev visit: https://github.com/jackoelv/KOL/
 */

 contract Ownable {
     address public owner;

     constructor() public{
         owner = msg.sender;
     }

     modifier onlyOwner {
         require(msg.sender == owner);
         _;
     }
     function transferOwnership(address newOwner) onlyOwner public{
         if (newOwner != address(0)) {
             owner = newOwner;
         }
     }
 }
 /**
  * title KOL Promotion contract
  * dev visit: https://github.com/jackoelv/KOL/
 */
 //测试说明，把一天改成1分钟。提现限制为5分钟。
contract KOLWithDraw is Ownable{
  using SafeMath for uint256;
  string public name = "KOL Promotion";
  KOL public kol;
  KOLP public kolp;
  address public reciever;

  uint256 public begin;//2020年4月22日0点0分0秒
  uint256 public end;

  uint256 public iCode;
  uint256 public every = 10 seconds;//1 days;
  uint256 public maxSettleDays = 1;
  uint256 public totalRegister;
  uint256 public totalBalance;
  uint256 public totalBonus;



  uint8 public constant userLevel1 = 20;
  uint8 public constant userLevel2 = 10;

  /* uint16 public constant comLevel1Users = 100;
  uint16 public constant comLevel2Users = 300;
  uint16 public constant comLevel3Users = 500; */

  //测试的时候就把数字变小一点。
  uint16 public constant comLevel1Users = 2;
  uint16 public constant comLevel2Users = 3;
  uint16 public constant comLevel3Users = 4;

  uint256 public constant comLevel1Amount = 10000 * (10 ** 18);
  uint256 public constant comLevel2Amount = 30000 * (10 ** 18);
  uint256 public constant comLevel3Amount = 50000 * (10 ** 18);

  uint8 public constant comLevel1 = 3;
  uint8 public constant comLevel2 = 5;
  uint8 public constant comLevel3 = 10;
  uint8 public constant withDrawRate = 5;
  uint8 public constant fee = 5;

  /* uint256 public constant withDrawDays = 30 days; */
  //测试限制5分钟
  uint256 public constant withDrawDays = 2 minutes;

  /* address[] private inviteAddr;// A->B->C: inviteAddr= B,A
  address[] private childAddr;// A-->B,A-->C,childAddr= B, C */



  struct lock{
    uint256 begin;
    uint256 amount;
    uint256 end;
    bool withDrawed;
  }

  struct teamRate{
    uint8 rate;
    uint256 changeTime;

  }

  struct inviteBonus{
    uint256 begin;//网体开始时间
    uint256 dayBonus;//网体当日加速
    uint256 hisTotalBonus;
  }
  struct withDraws{
    uint256 time;
    uint256 amount;
  }
  struct dayTeamBonus{
    uint256 theDayLastSecond;
    uint256 theDayTeamBonus;
    uint256 totalTeamBonus;
    uint8 theDayRate;
  }
  struct dayInviteBonus{
    uint256 theDayLastSecond;
    uint256 theDayInviteBonus;
    uint256 totalInviteBonus;
  }



  mapping (address => dayTeamBonus[]) internal LockTeamBonus;
  mapping (address => dayInviteBonus[]) internal LockInviteBonus;


  mapping (address => address[]) internal InviteList;
  mapping (address => address[]) internal ChildAddrs;
  mapping (address => teamRate[]) internal TeamRateList;
  mapping (address => lock[]) internal LockHistory;
  mapping (address => uint256) internal LockBalance;

  mapping (address => uint256) internal InviteHistoryBonus;
  mapping (address => uint256) internal InviteCurrentDayBonus;

  mapping (address => address) internal InviteRelation;//A=>B B is father;
  mapping (uint256 => uint256) public ClosePrice;//需要给个默认值，而且还允许修改，否则忘记就很麻烦了。
  mapping (address => uint256) internal TotalUsers;
  mapping (address => uint256) internal TotalLockingAmount;
  mapping (uint256 => address) public InviteCode;
  mapping (address => uint256) public RInviteCode;

  mapping (address => uint8) internal isLevelN;
  mapping (uint8 => uint8) internal levelRate;
  mapping (address => bool) public USDTOrCoin;

  mapping (address => uint256) internal WithDraws;
  mapping (address => mapping (address => uint256) ) ABTeamBonus;//A是下级，B是上级，ABBonus就是A给B加速的总数。
  mapping (address => mapping (address => uint256) ) ABInviteBonus;//A是下级，B是上级，ABBonus就是A给B加速的总数。

  //GAS优化

  event Registed(address _user,uint256 inviteCode);
  event GradeChanged(address _user,uint8 _oldLevel,uint8 _newLevel);
  event WithDraw(address _user,uint256 _amount);
  event WithDrawBalance(address _user,uint256 _balance);


  constructor(address _tokenAddress,address _kolpAddress) public {
    kol = KOL(_tokenAddress);
    kolp = KOLP(_kolpAddress);
  }
  /**
   * title 提现KOL到自己的账户
   * dev visit: https://github.com/jackoelv/KOL/
  */
  function withDraw(bool _type) public {
    //_type true，提利息，false，提本息
    //提现就把利息全部提走，只能提整数，不能提小数点。
    //如果是提现本金，需要判断一下用户是否满足自由提现的条件。
    uint256 balance;
    require(LockBalance[msg.sender] > 0);
    uint256 selfBonus = calcuBonus(msg.sender,now);
    uint256 teamBonus;
    uint256 inviteBonus;
    uint256 index;
    (teamBonus,  index) = calcuTeamBonus(msg.sender,now);
    (inviteBonus,index) = calcuInviteBonus(msg.sender,now);
    uint256 allBonus = selfBonus + teamBonus + inviteBonus;

    uint256 currentTime;
    if (now > end)
      currentTime = end;
    else
      currentTime = now;

    if (!_type) {
      //本息一起提
      //今天凌晨的时间
      //提本金，先判断是否符合条件，一旦提了本金就要注意给上级网体降级减少网体的加速。
      if ((TotalLockingAmount[msg.sender] < LockBalance[msg.sender].mul(withDrawRate)) &&
                                    (currentTime < LockHistory[msg.sender][0].begin + withDrawDays)){
          //没有达到提现要求
          return;
      }else{

        /* last = LockHistoryBonus[msg.sender].length - 1;
        leftBonus = LockHistoryBonus[msg.sender][last].leftBonus; */
        for (uint j = 0; j<LockHistory[msg.sender].length; j++){
          LockHistory[msg.sender][j].end = currentTime;
          LockHistory[msg.sender][j].withDrawed = true;
        }
        balance = LockBalance[msg.sender];
        emit WithDrawBalance(msg.sender,balance);
        /* kol.transfer(msg.sender,balance); */
        LockBalance[msg.sender] = 0;
        afterDraw(msg.sender,balance,teamBonus,inviteBonus,index);//提现以后需要对上级所有的网体人数和金额做减法。
      }

    }
    uint256 realWithdraw = allBonus.mul(100-fee).div(100).add(balance);
    require(realWithdraw > 0);
    WithDraws[msg.sender] += realWithdraw;
    kol.transfer(msg.sender,realWithdraw);
    emit WithDraw(msg.sender,realWithdraw);
    kol.transfer(reciever,allBonus.mul(fee).div(100));
  }
  /**
   * title 提现以后上级的处理
   * dev visit: https://github.com/jackoelv/KOL/
  */
  function afterDraw(address _addr,uint256 _amount,uint256 _teamBonus,uint256 _inviteBonus,uint256 _lockIndex) private{
    //还有问题的。
    subselfBonus(_addr,_teamBonus,_inviteBonus);
    for (uint i = 0; i<InviteList[_addr].length; i++){
        require(TotalUsers[InviteList[_addr][i]] > 0);
        TotalUsers[InviteList[_addr][i]] -= 1;
        //给上面的加入团队总金额
        TotalLockingAmount[InviteList[_addr][i]] = TotalLockingAmount[InviteList[_addr][i]].sub(_amount);
        queryAndSetLevelN(InviteList[_addr][i]);
        ABTeamBonus[_addr][InviteList[_addr][i]] =0;
        ABInviteBonus[_addr][InviteList[_addr][i]] =0;
    }
  }
  function subselfBonus(address _selfAddr,uint256 _teamBonus,uint256 _inviteBonus) internal {
    //自己提了利息，应该就把利息减掉。
    uint256 todayLastSecond = getYestodayLastSecond(now) + every;
    uint256 last;
    uint256 lastDayLastSecond;
    if(LockTeamBonus[_selfAddr].length > 0){
      last = LockTeamBonus[_selfAddr].length -1;
      lastDayLastSecond = LockTeamBonus[_selfAddr][last].theDayLastSecond;
      if (lastDayLastSecond < todayLastSecond){
        //增加一条记录，当日速度需要降低吗？不需要。总体余额需要降低
        //
         LockTeamBonus[_selfAddr].push(dayTeamBonus(todayLastSecond,
                                                    LockTeamBonus[_selfAddr][last].theDayTeamBonus,
                                                    0,
                                                    LockTeamBonus[_selfAddr][last].theDayRate));
      }else{
        //=或者大于
        for (uint i = last ; i >=0; i-- ){
          //修改记录
           if (LockTeamBonus[_selfAddr][i].theDayLastSecond >= todayLastSecond)
            LockTeamBonus[_selfAddr][i].totalTeamBonus -= _teamBonus;
           else
            break;
        }
      }
    }

    if (LockInviteBonus[_selfAddr].length >0){
      last = LockInviteBonus[_selfAddr].length -1;
      lastDayLastSecond = LockInviteBonus[_selfAddr][last].theDayLastSecond;
      if (lastDayLastSecond < todayLastSecond){
        //增加一条记录
        LockInviteBonus[_selfAddr].push(dayInviteBonus(todayLastSecond,
                                                   LockInviteBonus[_selfAddr][last].theDayInviteBonus,
                                                   0));
      }else{
        //=或者大于
        for (i = last ; i >=0; i-- ){
          //修改记录
           if (LockInviteBonus[_selfAddr][i].theDayLastSecond >= todayLastSecond)
            LockInviteBonus[_selfAddr][i].totalInviteBonus -= _inviteBonus;
           else
            break;
        }
      }
    }

  }
  function subTopBonus(address _selfAddr,address _topAddr,bool _isInvite) internal {
    //自己提了本金，就应该把上级的加速减掉。
    uint256 todayLastSecond = getYestodayLastSecond(now) + every;
    uint256 last;
    uint256 lastDayLastSecond;


    if(LockTeamBonus[_topAddr].length > 0){
      last = LockTeamBonus[_topAddr].length -1;
      lastDayLastSecond = LockTeamBonus[_topAddr][last].theDayLastSecond;
      if (lastDayLastSecond < todayLastSecond){
        //增加一条记录，当日速度需要降低吗？不需要。总体余额需要降低
        //
         uint256 lastingDays = (todayLastSecond - lastDayLastSecond) % every;
         uint256 theDayTeamBonus = LockTeamBonus[_topAddr][last].theDayTeamBonus - ABTeamBonus[_selfAddr][_topAddr];
         uint256 totalTeamBonus = LockTeamBonus[_topAddr][last].totalTeamBonus - ABTeamBonus[_selfAddr][_topAddr];
         uint8 theDayRate = LockTeamBonus[_topAddr][last].theDayRate;
         LockTeamBonus[_topAddr].push(dayTeamBonus(todayLastSecond,
                                                    todayLastSecond,
                                                    totalTeamBonus ,
                                                    theDayRate));
      }else{
        //=或者大于
        for (uint i = last ; i >=0; i-- ){
          //修改记录
          lastDayLastSecond = LockTeamBonus[_topAddr][last].theDayLastSecond;
           if (lastDayLastSecond >= todayLastSecond){
             uint256 lastingDays2 =(lastDayLastSecond-todayLastSecond) % every +1;
             LockTeamBonus[_selfAddr][i].theDayTeamBonus -= ABTeamBonus[_selfAddr][_topAddr];
             LockTeamBonus[_selfAddr][i].totalTeamBonus -= lastingDays2 * ABTeamBonus[_selfAddr][_topAddr];
           }else
              break;
        }
      }

    }


    if (_isInvite){
      if (LockInviteBonus[_topAddr].length >0){

      }
    }





    ABTeamBonus[_selfAddr][_topAddr] = 0;
    if (_isInvite)
      ABInviteBonus[_selfAddr][_topAddr] = 0;

  }




  /**
   * title 查询到指定时间点，用户累计的持币生息收益，建议输入时间为当天的11点59分
   * dev visit: https://github.com/jackoelv/KOL/
  */
  function calcuBonus(address _addr,uint256 _queryTime) private view returns(uint256) {
    // 一会儿再来修改。-- 4.28输入参数为查询的时间。
    //返回值为截止到查询时间之前当天的静态收益。
    //金本位考虑进来。
    require(_queryTime <= end);
    uint256 tmpBonus;
    uint256 yestodayLastSecond;
    uint256 theDaylastSecond;
    uint256 tmpCalcu;
    if (LockHistory[_addr].length > 0){
      for (uint i = 0; i<LockHistory[_addr].length; i++){
        if  (!LockHistory[_addr][i].withDrawed){
          if (_queryTime > LockHistory[_addr][i].begin){
            uint256 lastingDays = (_queryTime - LockHistory[_addr][i].begin) % every;
            if (USDTOrCoin[_addr]){
              yestodayLastSecond = getYestodayLastSecond(_queryTime);
              theDaylastSecond = getYestodayLastSecond(LockHistory[_addr][i].begin) + every;
              for (uint j = theDaylastSecond; j<=yestodayLastSecond; j=j+every){
                tmpCalcu += LockHistory[_addr][i].amount * 3 / 1000 * ClosePrice[theDaylastSecond] / ClosePrice[j];
              }
            }else{
              tmpCalcu += lastingDays * LockHistory[_addr][i].amount * 3 / 1000;
            }
          }
        }

      }
    }
    return tmpBonus;
  }

  function calcuBonusP(uint256 _queryTime) public view returns(uint256){
    return(calcuBonus(msg.sender,_queryTime));
  }


  /**
   * title 查询并计算用户的网体收益
   * dev visit: https://github.com/jackoelv/KOL/
  */
  function getLast(address _addr,bool _type) private view returns(uint256){
    if (_type)
      return(LockTeamBonus[_addr].length -1);
    else
      return(LockInviteBonus[_addr].length -1);
  }
  function getLastSecond(address _addr,uint _index,bool _type) private view returns(uint256){
    if (_type){
      return(LockTeamBonus[_addr][_index].theDayLastSecond);
    }else {
      return(LockInviteBonus[_addr][_index].theDayLastSecond);
    }
  }
  function getTheDayTeamBonus(address _addr,uint _index,bool _type) private view returns(uint256){
    if (_type)
      return(LockTeamBonus[_addr][_index].theDayTeamBonus);
    else
      return(LockInviteBonus[_addr][_index].theDayInviteBonus);

  }
  function getTotalTeamBonus(address _addr,uint _index,bool _type) private view returns(uint256){
    if (_type)
      return(LockTeamBonus[_addr][_index].totalTeamBonus);
    else
      return(LockInviteBonus[_addr][_index].totalInviteBonus);

  }
  function getRate(address _addr,uint _index) private view returns(uint8){
    return(LockTeamBonus[_addr][_index].theDayRate);
  }

  /**
   * title 根据给定时间计算出昨天的最后一秒
   * dev visit: https://github.com/jackoelv/KOL/
  */
  function getYestodayLastSecond(uint256 _queryTime) private view returns(uint256){
    //录入的价格为4位小数
    /* return (_queryTime.sub(_queryTime.sub(begin) % 86400) - 1); */
    //测试 上一分钟的最后一秒
    require(_queryTime <= (end + every));
    return (_queryTime.sub(_queryTime.sub(begin) % every) - 1);
  }
  /**
   * title 获得自己的邀请码
   * dev visit: https://github.com/jackoelv/KOL/
  */
  function getCode() public view returns(uint256) {
    return (RInviteCode[msg.sender]);
  }
  /**
   * title 查询自己的直推下级
   * dev visit: https://github.com/jackoelv/KOL/
  */
  function getTeam() public view returns(address[]) {
    return (ChildAddrs[msg.sender]);
  }
  /**
   * title 查询自己的网体人数
   * dev visit: https://github.com/jackoelv/KOL/
  */
  function getTeamTotalUsers() public view returns(uint256) {
    return (TotalUsers[msg.sender]);
  }
  /**
   * title 查询自己的网体金额
   * dev visit: https://github.com/jackoelv/KOL/
  */
  function getTeamTotalAmount() public view returns(uint256) {
    return (TotalLockingAmount[msg.sender]);
  }
  /**
   * title 查询自己的锁仓历史
   * dev visit: https://github.com/jackoelv/KOL/
  */
  function getLockHistory(uint _index) public view returns(uint256,uint256,uint256,bool,uint256) {
    require( (_index<(LockHistory[msg.sender].length)) && (_index>=0) );
    return(LockHistory[msg.sender][_index].begin,
                LockHistory[msg.sender][_index].end,
                LockHistory[msg.sender][_index].amount,
                LockHistory[msg.sender][_index].withDrawed,
                LockHistory[msg.sender].length);
  }

  /**
   * title 查询自己过去每日的收益汇总。
   * dev visit: https://github.com/jackoelv/KOL/
  */
  function getHistoryTeamBonus(address _addr,uint256 _index) public view returns(uint256,uint256,uint256,uint256,uint256){
    //返回查询昨天的收益。
    if (LockTeamBonus[_addr].length > _index){
      return (LockTeamBonus[_addr][_index].theDayLastSecond,
              LockTeamBonus[_addr][_index].theDayTeamBonus,
              LockTeamBonus[_addr][_index].totalTeamBonus,
              LockTeamBonus[_addr][_index].theDayRate,
              LockTeamBonus[_addr].length);
    }else{
      return(0,0,0,0,0);
    }
  }
  function getHistoryInviteBonus(address _addr,uint256 _index) public view returns(uint256,uint256,uint256,uint256){
    //返回查询昨天的收益。
    if (LockInviteBonus[_addr].length > _index){
      return (LockInviteBonus[_addr][_index].theDayLastSecond,
              LockInviteBonus[_addr][_index].theDayInviteBonus,
              LockInviteBonus[_addr][_index].totalInviteBonus,
              LockInviteBonus[_addr].length);
    }else{
      return(0,0,0,0);
    }
  }




}
